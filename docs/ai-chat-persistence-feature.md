# AI Chat Persistence Feature

## Overview
Enable persistent storage of AI assistant conversations to allow users to reference past discussions, continue conversations across sessions, and build up knowledge over time.

## Design Decisions

### Conversation Organization
- **Naming**: Organize by date with user ability to rename conversations
- **Dynamic tagging**: Auto-generate tags based on conversation content/topics
- **Wine context**: Conversations tied to specific selected wines from cellar

### Data Persistence
- **Retention policy**: Keep conversations forever with manual delete capability
- **Performance monitoring**: Track token usage per conversation and session
- **Wine context storage**: Store wine IDs + search state, regenerate wine context dynamically
- **Context evolution**: When search criteria match new wines, offer to add them to conversation context

### User Experience  
- **Conversation scoping**: Scope conversations to OAuth email (user-specific)
- **Search**: Implement DB-level string searching across conversation content
- **No sharing/export initially**: Keep it simple to start

### Conversation Branching Ideas
Several approaches to consider:
1. **Duplicate & Branch**: Copy existing conversation as new branch when user wants to explore different topic
2. **Conversation Templates**: Create template from existing conversation for similar discussions
3. **Topic Forking**: Allow "forking" at specific message to explore alternative responses
4. **Wine Re-attachment**: Allow switching wine context mid-conversation to explore different wines

### UI Flow Design Considerations
Key UI patterns to develop:
- **Conversation sidebar**: Collapsible list with recent conversations
- **Quick actions**: New conversation, duplicate, delete, rename
- **Wine context switcher**: Easy way to change which wines are in scope for conversation
- **Search/filter**: Find conversations by content or wine names
- **Mobile adaptation**: How to handle conversation management on smaller screens

## Implementation Plan

### Phase 1: Database Schema

#### New Tables
```sql
-- Conversations table
CREATE TABLE ai_conversations (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_email VARCHAR(255) NOT NULL, -- Scope to OAuth email
    title VARCHAR(255),
    wine_ids INTEGER[], -- Current wine IDs in conversation context
    wine_search_state JSONB, -- Store the search/filter state that selected these wines
    auto_tags VARCHAR(100)[], -- Dynamic tags based on content
    total_tokens_used INTEGER DEFAULT 0, -- Track total token usage
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    last_message_at TIMESTAMP DEFAULT NOW()
);

-- Messages table  
CREATE TABLE ai_conversation_messages (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    conversation_id INTEGER NOT NULL REFERENCES ai_conversations(id) ON DELETE CASCADE,
    is_user BOOLEAN NOT NULL,
    content TEXT NOT NULL,
    image_data BYTEA, -- For messages with images
    tokens_used INTEGER, -- Track tokens used for this message/response
    created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_messages_conversation_id ON ai_conversation_messages(conversation_id);
CREATE INDEX idx_messages_created_at ON ai_conversation_messages(created_at);
CREATE INDEX idx_conversations_user_email ON ai_conversations(user_email);
CREATE INDEX idx_conversations_last_message ON ai_conversations(user_email, last_message_at DESC);
CREATE INDEX idx_conversations_wine_ids ON ai_conversations USING GIN(wine_ids);
CREATE INDEX idx_conversations_content_search ON ai_conversation_messages USING GIN(to_tsvector('english', content));
```

### Phase 2: Backend API

#### New Endpoints
- `GET /api/conversations` - List user's conversations with metadata
- `POST /api/conversations` - Create new conversation (with wine_ids context)
- `GET /api/conversations/:id` - Get full conversation with messages
- `PUT /api/conversations/:id` - Update conversation (rename, change wine context)
- `DELETE /api/conversations/:id` - Delete conversation
- `POST /api/conversations/:id/messages` - Add message to conversation (track tokens)
- `POST /api/conversations/:id/duplicate` - Duplicate conversation for branching
- `PUT /api/conversations/:id/wine-context` - Change wine context for conversation
- `POST /api/conversations/:id/suggest-wines` - Check if search criteria matches new wines
- `GET /api/conversations/search?q=...` - Search conversations by content
- `GET /api/conversations/by-wine/:wine_id` - Find conversations involving specific wine

#### Database Functions
- `create-conversation` - Create new conversation
- `get-conversations` - List conversations with pagination
- `get-conversation-with-messages` - Load full conversation
- `add-message-to-conversation` - Append message
- `update-conversation-timestamp` - Update last_message_at
- `delete-conversation` - Remove conversation and messages

### Phase 3: Frontend State Management

#### State Structure
```clojure
(def app-state
  (atom {:conversations {:current-id nil
                         :list []
                         :current-messages []
                         :loading? false}
         :chat {:message ""
                :image nil}}))
```

#### State Management Functions  
- `load-conversations` - Fetch conversation list
- `load-conversation` - Load specific conversation messages
- `create-new-conversation` - Start fresh conversation
- `switch-conversation` - Change active conversation
- `save-message` - Persist message to current conversation
- `delete-conversation` - Remove conversation

### Phase 4: UI Components

#### New Components
- `conversation-list` - Sidebar showing all conversations
- `conversation-item` - Individual conversation in list
- `conversation-header` - Current conversation title/controls
- `new-conversation-button` - Create new conversation
- `conversation-actions` - Rename/delete controls

#### Modified Components  
- `wine-chat` - Integrate with conversation persistence
- `main-layout` - Add conversation sidebar toggle
- Mobile responsive conversation management

### Phase 5: Migration & Deployment

#### Migration Strategy
- Database migration to create new tables
- No existing data to migrate (conversations are new feature)
- Feature flag for gradual rollout if needed

#### Configuration
- Add conversation retention policy setting
- Configure max messages per conversation limit
- Set conversation list pagination size

## Technical Considerations

### Performance Optimizations
- Lazy load conversation messages (don't load all at once)
- Implement conversation list pagination
- Cache current conversation in frontend state
- Use database indexes for efficient conversation queries

### Error Handling
- Handle network failures gracefully when saving messages
- Implement retry logic for failed message saves
- Show loading states during conversation switches
- Graceful fallback if conversation fails to load

### Testing Strategy
- Unit tests for database functions
- API endpoint testing
- Frontend state management testing
- End-to-end conversation flow testing

## Detailed Branching Mechanisms

### 1. Simple Duplication
- **"Duplicate Conversation"** button creates exact copy with new title
- Original conversation remains unchanged
- User can immediately ask different question in new branch
- **Pros**: Simple, clear, preserves original
- **Cons**: Full duplication might waste storage

### 2. Fork at Message
- **"Fork from here"** button on any AI response
- Creates new conversation starting from that message point
- Preserves context up to fork point
- **Pros**: More precise branching, saves storage
- **Cons**: More complex UI, harder to understand lineage

### 3. Template Creation
- **"Save as Template"** converts conversation to reusable starting point
- Template includes wine context and initial questions
- **Use case**: "Dinner party planning template" with your selected wines
- **Pros**: Enables reusable conversation patterns
- **Cons**: Additional complexity for template management

### 4. Wine Context Evolution
- **Dynamic context updates**: When search criteria matches new wines, show notification
- **"Add New Wines?"** prompt when conversation's search state finds new matches
- **Search state preservation**: Store original filter/search that selected wines
- **Manual context updates**: User can add/remove specific wines from conversation
- **Use cases**: 
  - Conversation about "Burgundy under $50" automatically suggests newly added wines that match
  - "2015 Bordeaux" conversation gets updated when you add new 2015 Bordeaux wines
- **Pros**: Conversations grow naturally with collection, maintains search intent
- **Cons**: Need to handle notification timing and frequency

### 5. Context Management UX Ideas
- **Wine context sidebar**: Shows current wines in conversation with ability to add/remove
- **"Refresh Context"** button: Re-run search criteria to find new matches
- **Context change indicators**: Show in conversation when wine context was modified
- **Search state display**: Show what search/filter criteria is driving wine selection

**Recommended Starting Point**: Simple duplication + dynamic context evolution for v1

## Context Evolution Challenge

### The Problem
When wine context changes mid-conversation, we're essentially changing the system prompt. This is a common challenge in AI systems with evolving knowledge bases and can cause:
- **Inconsistent responses**: Same question gets different answers after context updates
- **User confusion**: Why did the AI's answer change?
- **AI confusion**: Potentially conflicting information in context

### Best Practice Approaches

#### 1. Explicit Context Change Notifications
```
System message: "CONTEXT UPDATE: Since our last exchange, your wine collection now includes 3 new wines that match our search criteria: [list]. I'll incorporate this new information in my responses."
```

#### 2. Incremental Context Prompting
Instead of replacing entire wine context, append changes:
```
System prompt: "Your wine collection now also includes: [new wines]. This is in addition to the wines we were previously discussing."
```

#### 3. Context Versioning
- Track context changes with timestamps
- Show users when context was last updated
- Option to "freeze context" to maintain conversation consistency

#### 4. Context Change Messages
Add system messages to conversation history when context changes:
```
[System: Wine collection updated - added 2 Burgundies, removed 1 Bordeaux]
```

#### 5. Smart Context Management
- **Token-aware**: Summarize older wines when context gets too large
- **Relevance-based**: Only include wines relevant to current conversation topic
- **User choice**: "Continue with current context" vs "Update with new wines"

### Implementation Strategy

#### Database Changes
```sql
-- Add context versioning
ALTER TABLE ai_conversations ADD COLUMN context_version INTEGER DEFAULT 1;
ALTER TABLE ai_conversation_messages ADD COLUMN context_version_at_message INTEGER;

-- Track context change events
CREATE TABLE ai_conversation_context_changes (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    conversation_id INTEGER NOT NULL REFERENCES ai_conversations(id) ON DELETE CASCADE,
    change_type VARCHAR(50), -- 'wines_added', 'wines_removed', 'search_updated'
    old_wine_ids INTEGER[],
    new_wine_ids INTEGER[],
    change_description TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);
```

#### Context Management Functions
- `detect-context-changes` - Compare current search results with stored wine_ids
- `apply-context-update` - Add system message and update wine context
- `get-context-diff` - Show what changed in wine selection
- `should-update-context` - Logic for when to suggest context updates

#### UX Flow
1. **Context change detection**: When loading conversation, check if search criteria yields new results
2. **User notification**: "3 new wines match your criteria - update conversation context?"
3. **System message injection**: Add explanation of context change to conversation
4. **Continue naturally**: AI incorporates new information in subsequent responses

**Recommended v1 Approach**: Explicit context change notifications + system messages

## Future Enhancements

### Advanced Features
- **Message forking**: Fork at specific message points
- **Conversation merging**: Combine insights from multiple conversations
- **Conversation templates**: Reusable conversation patterns
- **Message reactions**: Like/bookmark important AI responses
- **Wine recommendation tracking**: Track which AI suggestions were acted upon

### Analytics & Insights
- Track conversation engagement metrics
- Identify most helpful AI responses
- Wine recommendation success tracking
- Token usage analytics and cost optimization

## Estimated Effort
- **Phase 1** (Database): 4-6 hours
- **Phase 2** (Backend): 8-12 hours  
- **Phase 3** (Frontend State): 6-8 hours
- **Phase 4** (UI Components): 12-16 hours
- **Phase 5** (Migration/Testing): 4-6 hours

**Total**: 34-48 hours of development time

## Dependencies
- Requires authentication system (already implemented)
- Database migration capability (already available)
- Image handling for messages with photos (already implemented)